\chapter{copyright atari}
\label{sec:copyprotection}
\lhead[tempest]{}
\lstset{style=6502Style}

Making arcade games was an expensive business. The outlay in time and 
money expended on \textit{Tempest} was premised on selling enough units
to arcades in the United States and Europe to justify the investment. And once
the game became successful, Atari could fully expect unscrupulous entrepreneurs to
cash in on \textit{Tempest's} success by doing something much more profitable
than developing a game of their own from scratch. This shortcut to riches
involved patching the ROM boards to rename the game, apply some minimal
changes to the game's graphical assets, and rebadge it as their own product.

Atari laid a number of traps in the game's code to catch these guys out. The 
primary focus of nearly all of them was in ensuring that the copyright message
displayed throughout the game had not been tampered with. Each of these checks
consists of calculating a checksum value on some segment of data in the game and
ensuring that it contains the expected value.

\section*{\icode{QT1}: copyright atari}
An obvious place to check for tampering is in the copyright literal itself. This
is defined in \icode{ALLANG.MAC}:
\begin{lstlisting}
ZATLIS: ASCVH <^ MCMLXXX ATARI>
ZATLIE:
ZATLIC==ZATLIE-ZATLIS
\end{lstlisting}

Note that that the \copyright~  symbol is given as a circumflex. Also note that we've used
the labels \icode{ZATLIS} and \icode{ZATLIE} to identify the beginning and end of the
copyright literal - this allows us to calculate the length of the message at assembly
time and store it in \icode{ZATLIC}. We need this value because our check will be
to initialize the accumulator (\icode{A}) with a value of \icode{85}, iterate through the copyright
string in reverse order adding the value of each character to the accumulator, and store the result 
(which should be \icode{00}) in \icode{QT1}. The idea is that the cumulative additions will keep
wrapping around each time we reach 255 in the accumulator and when they are all complete our final
result will be zero, as long as the copyright message has not been tampered with.

\begin{lstlisting}
ZATLIV: CLC           ; CLEAR THE CARRY BIT.
        LDY I,ZATLIC  ; GET POS OF LAST CHAR IN STRING.
        LDA I,085     ; INITIALIZE QT1.
        BEGIN         ; LOOP THROUGH COPYRIGHT STRING.
        ADC Y,ZATLIS  ; ADD VALUE OF CURRENT CHARACTER.
        DEY           ; GO TO NEXT CHAR IN STRING.
        MIEND         ; KEEP LOOPING UNTIL END.
        STA QT1       ; VERIFY ATARI LITERAL
        RTS
\end{lstlisting}

Here is a rough visualization of the process. At each step we take in the value of the current
byte and add it to our accumulator giving us an updated value. Note that the start position of
our check is not the last character of the copyright string, but the byte after it (\icode{A0}). This may
have been intentional but it does look like a lurking off-by-one error, since we are including
a value in our checksum that does not strictly belong to the copyright literal.

\begin{figure}[H]
  {
    \setlength{\tabcolsep}{3.0pt}
    \setlength\cmidrulewidth{\heavyrulewidth} % Make cmidrule = 
    \begin{adjustbox}{width=10cm,center}
      \begin{tabular}{lcc}
        \toprule
    String So Far    &     Byte Value      &  Updated Accumulator.\\
        \midrule
        \includegraphics[width=4cm]{copyprotection/atari_14.png} & \icode{A0}  &  \icode{25} \\
        \includegraphics[width=4cm]{copyprotection/atari_14.png} & \icode{A6}  &  \icode{CB} \\
        \includegraphics[width=4cm]{copyprotection/atari_13.png} & \icode{38}  &  \icode{04} \\
        \includegraphics[width=4cm]{copyprotection/atari_12.png} & \icode{16}  &  \icode{1A} \\
        \includegraphics[width=4cm]{copyprotection/atari_11.png} & \icode{3C}  &  \icode{56} \\
        \includegraphics[width=4cm]{copyprotection/atari_10.png} & \icode{16}  &  \icode{6C} \\
        \includegraphics[width=4cm]{copyprotection/atari_9.png}  & \icode{00}  &  \icode{6C} \\
        \includegraphics[width=4cm]{copyprotection/atari_8.png}  & \icode{44}  &  \icode{B0} \\
        \includegraphics[width=4cm]{copyprotection/atari_7.png}  & \icode{44}  &  \icode{F4} \\
        \includegraphics[width=4cm]{copyprotection/atari_6.png}  & \icode{44}  &  \icode{39} \\
        \includegraphics[width=4cm]{copyprotection/atari_5.png}  & \icode{2C}  &  \icode{65} \\
        \includegraphics[width=4cm]{copyprotection/atari_4.png}  & \icode{2E}  &  \icode{93} \\
      \end{tabular}                                                                      
    \end{adjustbox}                                                                      
  }                                                                                      
\end{figure}

\begin{figure}[H]
  {
    \setlength{\tabcolsep}{3.0pt}
    \setlength\cmidrulewidth{\heavyrulewidth} % Make cmidrule = 
    \begin{adjustbox}{width=10cm,center}
      \begin{tabular}{lcc}
        \toprule
    String So Far    &     Byte Value      &  Updated Accumulator.\\
        \midrule
        \includegraphics[width=4cm]{copyprotection/atari_3.png}  & \icode{1A}  &  \icode{AD} \\
        \includegraphics[width=4cm]{copyprotection/atari_2.png}  & \icode{2E}  &  \icode{DB} \\
        \includegraphics[width=4cm]{copyprotection/atari_1.png}  & \icode{00}  &  \icode{DB} \\
        \includegraphics[width=4cm]{copyprotection/atari_0.png}  & \icode{50}  &  \icode{2C} \\
        \includegraphics[width=4cm]{copyprotection/atari_0.png}  & \icode{D3}  &  \icode{00} \\
      \end{tabular}                                                             
    \end{adjustbox}
  }
\end{figure}
The question now is what happens if we get a non-zero value, i.e. the checksum fails. The answer
is that we lie in wait and at some point make the game unplayable. Every time the display state
of the game's enemies is updated we check the value of \icode{QT1}. If it's not zero and the
player has advanced past the tenth level we set an impossibly high framerate. This will result
in enemies updating too quickly and will render the game unplayable.

\begin{lstlisting}
ZQATLI: LDA QT1       ; GET QT1.
        IFNE          ; IF IT'S NON ZERO..
        LDA WAVEN1    ; CHECK THE CURRENT LEVEL..
        CMP I,10.     ; IF IT'S GREATER THAN 10..
        IFCS          ; THEN..
        LDA I,7A      ; SET AN IMPOSSIBLE TO PLAY
        STA FRTIMR    ; FRAMERATE.
        ENDIF
        ENDIF
\end{lstlisting}


\section*{\icode{QT2}: copyright atari II}
We've checked the literal value in \icode{QT1}, but it's possible an enterprising pirate will find
another way of altering the copyright message displayed to the player. For example, they
could create an entirely new message instead of altering the existing one. Then all they
would have to do is updated the routine that displays the message to point at it. 
This code lives in the routine \icode{ZATC4S}. All we would have to do is change \icode{MATARI}
to reference our own pirated version, for example \icode{MPIRAT}. 

\begin{lstlisting}
ZATC4S: LDX I,MATARI  ; GET THE ATARI (C) MESSAGE.
        JSR MSGS      ; DISPLAY IT.
        LDX I,MCREDI  ; GET THE 'CREDITS' MESSAGE.
        JSR MSGS		  ; DISPLAY IT.
ZATC4E:
ZATC4C==ZATC4E-ZATC4S
\end{lstlisting}
So what we need to do to prevent this is to come up with a way of checking that this routine
itself has not been modified.
As before, notice how we identify the end of the code block by adding a label \icode{ZATC4E}
and then used that and the label at the start of the block (\icode{ZATC4S}) to calculate
the length of the code block and store it as \icode{ZATC4C}.
This comes in handy when we want to iterate through
the codeblock at runtime and verify that it hasn't been altered:
\begin{lstlisting}
ZATC4V: LDY I,ZATC4C		; GET THE LENGTH OF THE CODEBLOCK.
        LDA I,0A7       ; INITIALIZE OUR CHECKSUM. 
        BEGIN           ; LOOP THROUGH EACH BYTE IN THE CODEBLOCK.
        EOR Y,ZATC4S    ; XOR VAL OF CURRENT BYTE WITH CHECKSUM.
        DEY             ; GO TO NEXT BYTE
        MIEND           ; LOOP THROUGH FULL CODE BLOCK.
        STA QT2         ; STORE CHECKSUM IN Q2.
\end{lstlisting}

To give us an idea of what 'iterating through the codeblock' actually means, we have
to assemble the instructions at \icode{ZATC4S} to see the byte values that they 
correspond to. We list them below, side by side with the routine itself. As you can
see, the \icode{LDX} instruction maps to \icode{A2}, while the address for \icode{MATARI}
corresponds to a pair of bytes \icode{08} and \icode{92}, and so on.

\begin{minipage}[c]{0.40\linewidth}
\begin{lstlisting}[basicstyle=\scriptsize\ttfamily]
ZATC4S::                                         
        LDX I,MATARI             
        JSR MSGS                  
        LDX I,MCREDI             
        JSR MSGS                  
ZATC4E:                                                                       
\end{lstlisting}
\end{minipage}
\hspace{0.5cm}
\begin{minipage}[c]{0.40\linewidth}
\begin{lstlisting}[basicstyle=\scriptsize\ttfamily]
ZATC4S::                                         
        A2  2C
        20  AB14
        A2  2E
        20  AB14
ZATC4E:                                                                       
\end{lstlisting}
\vspace*{\fill}
\end{minipage}

With this in hand we can reconstruct the activity of \icode{ZATC4V} as it performs
an exclusive OR on each byte in the code block, in reverse order, computing a checksum for \icode{QT2}.
As with the computation of \icode{QT1} checksum, the 'off by one' nature of the loop means that
we actually pick up an extra byte (\icode{A5}), after the position \icode{ZATC4E} at the very 
start of our loop.

\begin{figure}[H]
  {
    \setlength{\tabcolsep}{3.0pt}
    \setlength\cmidrulewidth{\heavyrulewidth} % Make cmidrule = 
    \begin{adjustbox}{width=12cm,center}
      \begin{tabular}{lcc}
        \toprule
    Bytes So Far    &     Byte Value      &  Updated Checksum.\\
        \midrule
        \icode{~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~A5} & \icode{A5}  &  \icode{02} \\
        \icode{~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~14, A5} & \icode{14}  &  \icode{16} \\
        \icode{~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~AB, 14, A5} & \icode{AB}  &  \icode{BD} \\
        \icode{~~~~~~~~~~~~~~~~~~~~~~~~~~~~20, AB, 14, A5} & \icode{20}  &  \icode{9D} \\
        \icode{~~~~~~~~~~~~~~~~~~~~~~~~2E, 20, AB, 14, A5} & \icode{2E}  &  \icode{B3} \\
        \icode{~~~~~~~~~~~~~~~~~~~~A2, 2E, 20, AB, 14, A5} & \icode{A2}  &  \icode{11} \\
        \icode{~~~~~~~~~~~~~~~~14, A2, 2E, 20, AB, 14, A5} & \icode{14}  &  \icode{05} \\
        \icode{~~~~~~~~~~~~AB, 14, A2, 2E, 20, AB, 14, A5} & \icode{AB}  &  \icode{AE} \\
        \icode{~~~~~~~~20, AB, 14, A2, 2E, 20, AB, 14, A5} & \icode{20}  &  \icode{8E} \\
        \icode{~~~~2C, 20, AB, 14, A2, 2E, 20, AB, 14, A5} & \icode{2C}  &  \icode{A2} \\
        \icode{A2, 2C, 20, AB, 14, A2, 2E, 20, AB, 14, A5} & \icode{A2}  &  \icode{00  } \\
      \end{tabular}                                                             
    \end{adjustbox}
  }
\end{figure}

As we can see, the expected end result for our checksum, which we store in \icode{QT2}, is \icode{00}.
What delights are in store if the checksum is not zero? A brutal end: we use the \icode{SED}
instruction to switch the 6502 CPU to Binary Coded Decimal (BCD) mode. This has a fundamental impact
on how data is stored and calculations are performed. Any future computation will yield highly
unexpected values and result in all kinds of chaos, probably a very rapid and complete crash.

\begin{lstlisting}
ZQAT4C: LDA QT2    ; LOAD THE QT2 CHECKSUM.
        IFNE       ; IF IT'S NOT ZERO..
        LDA I,19.  ; LOAD 19 TO THE ACCUMULATOR. 
        CMP CURWAV ; IF THE CURRENT LEVEL..
        IFCC       ; IS GREATER THAN 19..
        SED        ; SWITCH THE CPU TO BINARY DECIMAL MODE.
        ENDIF
        ENDIF
\end{lstlisting}

\section*{\icode{QT3}: copyright atari III}
This one checks the contents of the vector display list used to render
the Atari copyright message (as well as everything else the game writes to the screen).
Since the copyright message is displayed on a few different
screens, with different colors, the contents of the display list can vary,
even when the Atari copyright banner is correctly displayed, so our checksum
has to tolerate a bit of variety.

Every time a message is written, the \icode{MSGS} routine checks if the
copyright message has been passed to it: if so, it stores the current
location in the display list in \icode{SECUVG} for checking later.

\begin{lstlisting}
ZSECL0: CPX I,MATARI
        IFEQ                    ;COPYRIGHT MSG?
        LDA VGLIST              ;YES. SAVE START LOC
        STA SECUVG
        LDA VGLIST+1
        STA SECUVG+1
        ENDIF
\end{lstlisting}

When the \icode{DISPLAY} routine runs, we are processing the contents
of the display list contained in \icode{VGLIST}. It's time for us to check
the portion that contains our hallowed copyright message. 
\begin{lstlisting}
ZATVG2::
  LDA SECUVY      ; ARE WE DISPLAYING ONE OF THE TITLE SCREENS?
  IFNE            ; IF WE ARE THEN:
  LDY I,27        ; FOR ALL 27 BYTES IN THE ROW.
  LDA I,0E        ; INITIALIZE OUR CHECKSUM VALUE
  SEC             ; CLEAR THE CARRY BIT SO IT DOESN'T INTERFERE
  ; LOOP THROUGH EACH CHARACTER IN THE LINE POINTED TO BY SECUVG
  ; THIS SHOULD CONTAIN '(C) MCMLXXX ATARI', OTHERWISE WE WILL GET
  ; AN INVALID CHECKSUM.
  BEGIN           ; LOOP FROM 27 TO 0
  SBC NY,SECUVG   ; SUBTRACT VALUE IN THE CURRENT CHAR FROM 'A' REGISTER.
  DEY             ; DECREMENT Y TO GO TO THE PREVIOUS CHARACTER.
  MIEND           ; LOOP UNTIL Y IS 0.
  TAY             ; STORE THE RESULT IN A IN Y.
  IFNE            ; IF THE RESULT IS ZERO, THE CHECKSUM PASSES OTHERWISE:
  EOR I,0E5       ; CHECK IT AGAINST THE CHECKSUM FOR ANOTHER SCREEN
  ENDIF           
  IFNE            ; IF THAT PASSES WE'RE DONE OTHERWISE:
  EOR I,02A       ; CHECK IT AGAINST THE CHECKSUM FOR ANOTHER SCREEN
  ENDIF           
  STA QT3         ; STORE THE RESULT OF OUR CHECK IN QT3.
  ENDIF
  ENDIF
\end{lstlisting}

\begin{lstlisting}
ZQVAVG::
  LDA QT3     ; CHECK THAT BOTH QT3 AND
  ORA QT6     ; QT6 ARE ZERO.
  IFNE        ; IF THEY ARE NOT THEN
  LDA I,17    ; CHECK IF THE PLAYER' SCORE IS GREATER THAN 170,000
  CMP LSCORH  ; LSCORH CONTAINS THE FIRST 2 DIGITS OF THE PLAYER SCORE
  IFCC        ; IF IT IS GREATER THAN OR EQUAL TO 17..
  LDX LSCORL  ; LOAD WHATEVER IS IN THE LSCORL BYTE
  INC X,0     ; AND USE THAT TO INCREMENT ONE OF OUR 'ZERO-PAGE' BYTES.
  ENDIF       ; IN THE HOPE OF CAUSING SOME HAVOC.
  ENDIF       ; HAVOC SECURED.
\end{lstlisting}

\section*{\icode{QT4}: sound check}
This tests the sound chips (known as 'pokeys') for expected behaviour. There are two sound chips on the 
board and each has a hardware-based random number generator. Retrieving a random number
from each, one after the other, should return matching values. If they don't, something is wrong.
The check is looking out for signs of the pokeys temporarily stopping when queried for a random
number. Don't know why this is bad.

\begin{lstlisting}
ZPOKST: LDX I,4     ; QUERY THE POKEYS 4 TIMES.
        LDA RANDOM  ; GET A RANDOM NUMBER FROM POKEY 1.
        LDY RANDO2  ; GET A RANDOM NUMBER FROM POKEY 2.
        BEGIN       ; LOOP AND COMPARE SUBSEQUENT VALUES 4 TIMES.
        CMP RANDOM  ; GET A NEW VALUE FROM POKEY 1 AND COMPARE TO ORIGINAL.
        IFEQ        ; IF IT MATCHES..
        CPY RANDO2  ; GET A NEW VALUE FROM POKEY 2 AND COMPARE TO ORIGINAL.
        ENDIF
        IFNE        ; IF NEITHER MATCHED, THEN STORE THE FAILURE..
        STA QT4     ; IN OUR QT4 CHECKSUM VALUE.
        LDX I,0     ; SKIP TO END BY SETTING X TO 0.
        ENDIF
        DEX         ; DECREMENT X
        MIEND       ; LOOP UNTIL X IS -1
\end{lstlisting}

If this check fails, then we are going to ruin the player's day by corrupting
the computer's stack. We do this in the \icode{DSPEXP} routine, so as long as you
never hit anything on your bootlegged version of \textit{Tempest}, you should be OK.

\begin{lstlisting}
ZQPOKS: LDA QT4     ; CHECK THE SOUND CHIP CHECKSUM.
        IFNE        ; IF IT FAILED THEN SET UP A BOMB..
        LDA CURWAV  ; GET THE CURRENT LEVEL..
        CMP I,13.   ; COMPARE IT TO 13.
        IFCS        ; IF IT IS GREATER THAN 13..
        STA 1FF     ; KILL TOP OF STACK
        ENDIF
        ENDIF
        RTS
\end{lstlisting}

\section*{\icode{QT5}: sound check II}

\begin{lstlisting}
        .SBTTL  DISPLAY HIGH SCORE LADDER
LDRDSP: JSR INFO                ;DISPLAY SCORE & LIVES INFO
ZPONTS: SEI          ; DISABLE INTERRUPTS.
        LDA RANDOM
        LDY RANDOM
        STY TEMP0
        LSR
        LSR
        LSR
        LSR
        EOR TEMP0
        STA TEMP0
        LDA RANDO2
        LDY RANDO2
        CLI         ; ALLOW INTERRUPTS AGAIN.
        EOR TEMP0
        AND I,0F0
        EOR TEMP0
        STA TEMP0
        TYA
        ASL
        ASL
        ASL
        ASL
        EOR TEMP0
        STA QT5     ; STORE THE RESULT IN QT5.
\end{lstlisting}

Randomly tagged on to the end of the display starfield routine (\icode{DSTARF}). 
If the score is greater than 150,000 then use the last few digits of the score
to randomly increment a byte in memory at position 200 or above. Like the damage
wrought in \icode{QT3} this will be done every time the starfield display is updated
during a level change so will inevitably, and promptly, bring the game to a crashing
halt.

\begin{lstlisting}
ZQPONS: LDA QT5
        IFNE
        LDX LSCORH
        CPX I,15
        IFCS
        LDX LSCORL
        INC X,200
        ENDIF
        ENDIF
        RTS
\end{lstlisting}

\section*{\icode{QT6}: copyright atari, one last time}
This is the same check as \icode{QT3} but is run in attract mode. The display list
is inspected and a checksum calculated on the line where the Atari copyright message
is expected to be.
\begin{lstlisting}
ZATVG1: LDA QSTATUS      ; ARE WE IN ATTRACT MODE?
        IFPL             ; IF YES THEN.. ATARI BETTER BE ON SCREEN
        LDA I,0F2        ; INITIALIZE THE CHECKSUM VALUE TO F2.
        CLC              ; CLEAR THE CARRY BIT.
        LDY I,39.        ; ITERATE OVER ALL 39 BYTES ON THE LINE
        BEGIN            ; LOOP THROUGH ALL 39 BYTES..
        ADC NY,SECUVG    ; ADDING THE VALUE AT EACH BYTE TO OUR CHECKSUM
        DEY              ; KEEP LOOPING FOR ALL 39.
        MIEND            ; END LOOP
        STA QT6          ; SAVE THE RESULT (WHICH SHOULD BE 0)
        ENDIF
\end{lstlisting}

Like \icode{QT3}, an invalid checksum in \icode{QT3}, will cause rapid corruption
of bytes in the zero-page area of the machine's memory. 
\begin{lstlisting}
ZQVAVG::
  LDA QT3     ; CHECK THAT BOTH QT3 AND
  ORA QT6     ; QT6 ARE ZERO.
  IFNE        ; IF THEY ARE NOT THEN
  LDA I,17    ; CHECK IF THE PLAYER' SCORE IS GREATER THAN 170,000
  CMP LSCORH  ; LSCORH CONTAINS THE FIRST 2 DIGITS OF THE PLAYER SCORE
  IFCC        ; IF IT IS GREATER THAN OR EQUAL TO 17..
  LDX LSCORL  ; LOAD WHATEVER IS IN THE LSCORL BYTE
  INC X,0     ; AND USE THAT TO INCREMENT ONE OF OUR 'ZERO-PAGE' BYTES.
  ENDIF       ; IN THE HOPE OF CAUSING SOME HAVOC.
  ENDIF       ; HAVOC SECURED.
\end{lstlisting}

